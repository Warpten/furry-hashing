#version 450

// Each work group has 64 inputs.
// Each input is a string in FourCC format, up to 32 indivual FourCC
// Say we want to compute the hashes of strings 'ABCD' and 'EFGH'.
// Our input would be { 'ABCD', 'EFGH' }.
//   Each invocation of the shader within the work group then operates on INPUT[gl_GlobalInvocationID.x].
//   Finally, output is written to HASH[gl_GlobalInvocationID.x].
// And the work group is done.

layout (local_size_x = 64) in;

struct input_words {
	uint word_count; // Actual number of words provided (in terms of bytes)
	uint words[32 * 3]; // Maximum size: 32 * 3 * 32 = 3072 B.
};

layout (std430, binding = 0) buffer _input_words {
	input_words INPUT[];
};

void main()
{
	uvec3 state;
	state.x = 0xDEADBEEFu;
	state.y = 0xDEADBEEFu;
	state.z = 0xDEADBEEFu + INPUT[gl_GlobalInvocationID.x].word_count;
	
	uint word_count = INPUT[gl_GlobalInvocationID.x].word_count;
	uint aligned_word_count = ((word_count + 2) & ~2) - 3;
	
	for (uint i = 0; i < aligned_word_count; i += 3)
	{
		state.x += INPUT[gl_GlobalInvocationID.x].words[i];
		state.y += INPUT[gl_GlobalInvocationID.x].words[i + 1];
		state.z += INPUT[gl_GlobalInvocationID.x].words[i + 2];

		state.x -= state.z;
		state.x ^= (state.z << 4) | (state.z >> 28);
		state.z += state.y;
		
		state.y -= state.x;
		state.y ^= (state.x << 6) | (state.x >> 26);
		state.x += state.z;
		
		state.z -= state.y;
		state.z ^= (state.y << 8) | (state.y >> 24);
		state.y += state.x;
		
		state.x -= state.z;
		state.x ^= (state.z << 16) | (state.z >> 16);
		state.z += state.y;
		
		state.y -= state.x;
		state.y ^= (state.x << 19) | (state.x >> 13);
		state.x += state.z;
		
		state.z -= state.y;
		state.z ^= (state.y << 4) | (state.y >> 28);
		state.y += state.x;
	}

	// We made sure to properly align on the cpu
	for (uint i = aligned_word_count; i < word_count; i++)
		state[i] += INPUT[gl_GlobalInvocationID.x].words[i - aligned_word_count];
	
	state.z ^= state.y;
	state.z -= (state.y << 14) | (state.y >> 18);

	state.x ^= state.z;
	state.x -= (state.z << 11) | (state.z >> 21);

	state.y ^= state.x;
	state.y -= (state.x << 25) | (state.x >> 7);

	state.z ^= state.y;
	state.z -= (state.y << 16) | (state.y >> 16);

	state.x ^= state.z;
	state.x -= (state.z << 4) | (state.z >> 28);

	state.y ^= state.x;
	state.y -= (state.x << 14) | (state.x >> 18);

	state.z ^= state.y;
	state.z -= (state.y << 24) | (state.y >> 8);

	INPUT[gl_GlobalInvocationID.x].word_count = state.z;
}

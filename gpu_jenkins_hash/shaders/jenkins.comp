#version 450

// Each work group has 64 inputs.
// Each input is a string in FourCC format, up to 32 indivual FourCC
// Say we want to compute the hashes of strings 'ABCD' and 'EFGH'.
// Our input would be { 'ABCD', 'EFGH' }.
//   Each invocation of the shader within the work group then operates on INPUT[gl_GlobalInvocationID.x].
//   Finally, output is written to HASH[gl_GlobalInvocationID.x].
// And the work group is done.

layout (local_size_x = 64) in;

struct input_words {
	uint char_count; // Number of bytes in the string
	uint words[32 * 3]; // Maximum size: 32 * 3 * 32 = 3072 B.
};

layout (std430, binding = 0) buffer _input_words {
	input_words INPUT[];
};

void main()
{
	uvec3 state;
	state.x = 0xDEADBEEFu + INPUT[gl_GlobalInvocationID.x].char_count;
	state.y = state.x;
	state.z = state.x;
	
	uint word_count = ((INPUT[gl_GlobalInvocationID.x].char_count + 3) & ~3) / 4;

	uint i = 0;
	for (; i < word_count - 3; i += 3)
	{
		state.x += INPUT[gl_GlobalInvocationID.x].words[i];
		state.y += INPUT[gl_GlobalInvocationID.x].words[i + 1];
		state.z += INPUT[gl_GlobalInvocationID.x].words[i + 2];

		state.x -= state.z;                          // a -= c
		state.x ^= (state.z << 4) | (state.z >> 28); // a ^= rot(c, 4)
		state.z += state.y;                          // c += b
		
		state.y -= state.x; 						 // b -= a
		state.y ^= (state.x << 6) | (state.x >> 26); // b ^= rot(a, 6)
		state.x += state.z;                          // a += c
		
		state.z -= state.y;                          // c -= b
		state.z ^= (state.y << 8) | (state.y >> 24); // c ^= rot(b, 8)
		state.y += state.x;							 // b += a
		
		state.x -= state.z;                          // a -= c
		state.x ^= (state.z << 16) | (state.z >> 16);// a ^= rot(c, 16)
		state.z += state.y;                          // c += b
		
		state.y -= state.x;                          // b -= a
		state.y ^= (state.x << 19) | (state.x >> 13);// b ^= rot(a, 19)
		state.x += state.z;                          // a += c
		
		state.z -= state.y;                          // c -= b
		state.z ^= (state.y << 4) | (state.y >> 28); // c ^= rot(b, 4)
		state.y += state.x;                          // b += a
	}

	state.x += INPUT[gl_GlobalInvocationID.x].words[i];
	state.y += INPUT[gl_GlobalInvocationID.x].words[i + 1];
	state.z += INPUT[gl_GlobalInvocationID.x].words[i + 2];
	
	state.z ^= state.y;							  // c ^= b
	state.z -= (state.y << 14) | (state.y >> 18); // c -= rot(b, 14)
    
	state.x ^= state.z;							  // a ^= c
	state.x -= (state.z << 11) | (state.z >> 21); // a -= rot(c, 11)
    
	state.y ^= state.x;							  // b ^= a
	state.y -= (state.x << 25) | (state.x >> 7);  // b -= rot(a, 25)
    
	state.z ^= state.y;							  // c ^= b
	state.z -= (state.y << 16) | (state.y >> 16); // c -= rot(b, 16)
    
	state.x ^= state.z;							  // a ^= c
	state.x -= (state.z << 4) | (state.z >> 28);  // a -= rot(c, 4)
    
	state.y ^= state.x;							  // b ^= a
	state.y -= (state.x << 14) | (state.x >> 18); // b -= rot(a, 14)
    
	state.z ^= state.y;							  // c ^= b
	state.z -= (state.y << 24) | (state.y >> 8);  // c -= rot(b, 24)

	INPUT[gl_GlobalInvocationID.x].char_count = state.z;
}
